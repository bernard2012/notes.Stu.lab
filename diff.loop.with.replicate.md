## How to call differential loops between two conditions with replicate samples

### Pre-requisites

In this tutorial, we will use Matr3 KO vs WT to illustrate the pipeline. For each, we have two HiC replicates. Each full set (KO and WT) is done at different time. Altogether there are 4 samples.

Here are their locations:

```bash
# KO0 day 0:
/n/scratch3/users/q/qz64/c2c12.scarlett.day0/210713_TL9104_fastq/output/hic_results/data/rep1.KO0
# NS0 day 0:
/n/scratch3/users/q/qz64/c2c12.scarlett.day0/210713_TL9104_fastq/output/hic_results/data/rep1.NS0
# NS0 day 0:
/n/scratch3/users/q/qz64/scarlett.c2c12.HiC.rep2/220305_TL9818_fastq/output/hic_results/data/WT01
# KO0 day 0:
/n/scratch3/users/q/qz64/scarlett.c2c12.HiC.rep2/220305_TL9818_fastq/output/hic_results/data/KO02
```

For each sample, we need the called loops. In short the following directories should be copied: **out2**, **out.OE**, **tmp2**.
```
cd /n/scratch3/users/q/qz64/c2c12.scarlett.day0/210713_TL9104_fastq/output/hic_results/data/rep1.KO0
cd hifi.out
# Need the *.RF.HIFI_MRF.tsv files (HMRF results)
ls -ltr
filtered_chrX_5000000_15000000_name.chrX_chrX.RF.HIFI_MRF.tsv
filtered_chrX_55000000_65000000_name.chrX_chrX.RF.HIFI_MRF.tsv
filtered_chrX_60000000_70000000_name.chrX_chrX.RF.HIFI_MRF.tsv
filtered_chrX_65000000_75000000_name.chrX_chrX.RF.HIFI_MRF.tsv
filtered_chrX_70000000_80000000_name.chrX_chrX.RF.HIFI_MRF.tsv
filtered_chrX_75000000_85000000_name.chrX_chrX.RF.HIFI_MRF.tsv
filtered_chrX_80000000_90000000_name.chrX_chrX.RF.HIFI_MRF.tsv
filtered_chrX_85000000_95000000_name.chrX_chrX.RF.HIFI_MRF.tsv
filtered_chrX_90000000_100000000_name.chrX_chrX.RF.HIFI_MRF.tsv
# Need the out2 directory containing just the loops_chr*.5kb.txt
cd ../out2
ls -ltr loops_chr*.txt
loops_chrY_75000000_85000000.10kb.txt
loops_chrY_75000000_85000000.25kb.txt
loops_chrY_75000000_85000000.50kb.txt
loops_chrY_75000000_85000000.5kb.txt
loops_chrY_80000000_90000000.10kb.txt
loops_chrY_80000000_90000000.25kb.txt
loops_chrY_80000000_90000000.50kb.txt
loops_chrY_80000000_90000000.5kb.txt
loops_chrY_85000000_95000000.10kb.txt
loops_chrY_85000000_95000000.25kb.txt
# Need the OE ratios (observed over expected ratios)
cd ../out.OE
ls -ltr chr*.gz
chrX_65000000_75000000.gz
chrX_70000000_80000000.2.gz
chrX_70000000_80000000.gz
chrX_75000000_85000000.2.gz
chrX_75000000_85000000.gz
chrX_80000000_90000000.2.gz
chrX_80000000_90000000.gz
chrX_85000000_95000000.2.gz
chrX_85000000_95000000.gz
chrX_90000000_100000000.2.gz
chrX_90000000_100000000.gz
```

### Re-run loops if XX.loops and XX.score does not exist (most likely the case):

First we need the loops to be in a special format. This special format can be generated by running `callPeaks.8frag` program. Copy the scripts over and compile the two c++ programs (`callPeaks.8frag.write.cpp` and `callPeaks.8frag.cpp`):

```bash
cd ../tmp2
cp ~/HIFI.bin/scripts/loop.compare/tmp2/do_one.sh .
cp ~/HIFI.bin/scripts/loop.compare/tmp2/do_one_loop.sh .
cp ~/HIFI.bin/scripts/loop.compare/tmp2/callPeaks.8frag.cpp .
cp ~/HIFI.bin/scripts/loop.compare/tmp2/callPeaks.8frag.write.cpp .
g++ -O4 -o callPeaks.8frag.write callPeaks.8frag.write.cpp -lm
g++ -O4 -o callPeaks.8frag callPeaks.8frag.cpp -lm
```

To run **callPeaks.8frag** requires making a loop list:
```bash
#sample loop.list:
chr10_0_10000000
chr10_100000000_110000000
chr10_10000000_20000000
chr1_0_10000000
chr10_105000000_115000000
chr10_110000000_120000000
chr10_115000000_125000000
chr10_120000000_130000000
chr10_125000000_135000000
chr10_130000000_140000000
chr10_15000000_25000000
chr10_20000000_30000000
chr10_25000000_35000000
chr10_30000000_40000000
chr10_35000000_45000000
chr10_40000000_50000000
chr10_45000000_55000000
chr10_50000000_60000000
chr10_5000000_15000000
chr10_55000000_65000000
chr10_60000000_70000000
chr10_65000000_75000000
...
```

There is an existing **loop.list** for mm10, copy them over. Here they have been split into 20 parts:
```bash
cp ~/HIFI.bin/scripts/loop.list.mm10/* .
ls loop.list*
loop.list    loop.list.10  loop.list.13  loop.list.16  loop.list.19  loop.list.4  loop.list.7
loop.list.0  loop.list.11  loop.list.14  loop.list.17  loop.list.2   loop.list.5  loop.list.8
loop.list.1  loop.list.12  loop.list.15  loop.list.18  loop.list.3   loop.list.6  loop.list.9
```

Run **callPeaks.8frag** on each of 20 parts to enable parallelization:
```bash
for i in `seq 0 19`; do sbatch ./do_one_loop.sh $i; done
for i in `seq 0 19`; do sbatch ./do_one.sh $i; done
```

- **callPeaks.8frag.write** prints *.score, a complete matrix of looping scores (for each fragment end `RF_end`'s interaction with another `RF_end`)
- **callPeaks.8frag** prints the **significant** loops' coordinates. A loop is significant if the looping score is above 1.0. Example of *.loop file:
```
#chr1   x1  x2  chr2    y1  y2  peak    score   strand1 strand2 color   observed    expected    BL  Donut   H   V   ratioBL ratioDonut  ratioH  ratioV
# juicer_tools version 1.11.09
chr8    80005298    80005299    chr8    80035442    80035443    80001929    80033255    1.181309
chr8    80005298    80005299    chr8    80124630    80124631    80001929    80129041    1.267601
chr8    80005298    80005299    chr8    80402907    80402908    80001929    80400616    1.220026
chr8    80010619    80010620    chr8    80491801    80491802    80001929    80497509    1.067717
chr8    80010619    80010620    chr8    80806560    80806561    80001929    80810160    1.028923
chr8    80005298    80005299    chr8    80946253    80946254    80001929    80950382    1.193739
chr8    80005298    80005299    chr8    81056910    81056911    80001929    81056910    1.019919
chr8    80010619    80010620    chr8    81181006    81181007    80001929    81181006    1.025437
chr8    80005298    80005299    chr8    82107775    82107776    80001929    82107775    1.069156
chr8    80005298    80005299    chr8    82767364    82767365    80001929    82764299    1.037557
chr8    80010619    80010620    chr8    83171565    83171566    80001929    83175271    1.063857
chr8    80005298    80005299    chr8    83358135    83358136    80001929    83362212    1.009016
chr8    80005298    80005299    chr8    83568084    83568085    80001929    83557468    1.042716
chr8    80005298    80005299    chr8    83568084    83568085    80001929    83561943    1.034126
chr8    80005298    80005299    chr8    83652235    83652236    80001929    83652235    1.152837
```
Note:
1. Columns 1, 2, 3: *ignore*
2. Columns 4, 5, 6: *ignore*
3. Column 7: looping score's corresponding x-coordinate (anchor1) i.e. *i*. In RF_end.
4. Column 8: looping score's corresponding y-coordinate (anchor2) i.e. *j*. In RF_end.
5. Column 9: `score[i, j]` (looping score value)

When finished, one should see:
```bash
[qz64@compute-a-16-163 tmp2]$ ls -ltr chr8*_70000000*
-rw-rw-r-- 1 qz64 qz64 130110269 Apr 17 22:19 chr8_60000000_70000000.score
-rw-rw-r-- 1 qz64 qz64 131982039 Apr 17 22:20 chr8_70000000_80000000.score
-rw-rw-r-- 1 qz64 qz64   3915141 Apr 18 02:16 chr8_60000000_70000000.loops
-rw-rw-r-- 1 qz64 qz64   4000332 Apr 18 02:17 chr8_70000000_80000000.loops
```

### Step 1: Consolidate OE scores

```
cd rep1.NS0/hifi.out
cp ~/HIFI.bin/scripts/loop.compare/hifi.out/significance.new.2.py .
cp ~/HIFI.bin/scripts/loop.compare/hifi.out/do_significance_new_2.sh .
mkdir significant.loopscore
cp ~/HIFI.bin/scripts/intervals.mm10/intervals.bed.* .
```

Note:
- **significance.new.2.py** consolidates the OE scores from all 4 samples, and their looping scores together and print them out. This is what it will print:
```
            print(t_key, t_chr1, t_end1, t_chr2, t_end2, t_index1, t_index2, \
            div_arr[t_index1, t_index2], ko_div_arr[t_index1, t_index2], \
            div2_arr[t_index1, t_index2], ko2_div_arr[t_index1, t_index2], \
            lscore_wt[t_index1, t_index2], lscore_ko[t_index1, t_index2], \
            lscore2_wt[t_index1, t_index2], lscore2_ko[t_index1, t_index2])
```
- lscore: looping score
- div_arr, ko_div_arr: interaction matrix (OE)
- t_index1, t_index2: indices

Run significance.new.2.py in a batch:
```bash
for i in `seq 0 19`; do sbatch ./do_significance_new_2.sh $i; done
```

```bash
# FYI only: content of do_significance_new_2.sh:
# python3 significance.new.2.py intervals.bed.$1 > significant.loopscore/$1
```

The output will be stored in `significant.loopscore`. Example output file:
```
[qz64@compute-a-16-163 hifi.out]$ head -n 10 significant.loopscore/1
chr1_140000000_150000000 chr1 144836210 chr1 149569544 1479 2942 0.8606050433944258 2.0059342976984236 2.216253592421129 1.324034759752668 0.8130488 1.1558389999999998 1.067835 0.9679308000000001
chr1_140000000_150000000 chr1 145667655 chr1 147703923 1742 2364 1.4678380225989736 0.6716699003941354 1.1128646853438215 1.643067377607956 1.213809 0.9431450000000001 0.871077 1.014073
chr1_140000000_150000000 chr1 144193554 chr1 147446660 1284 2284 1.4710377327501232 1.6094504648021541 1.4490534287154007 1.7478142738508973 0.8209063 0.9928563 1.092965 1.121693
chr1_140000000_150000000 chr1 143978168 chr1 147292742 1217 2238 1.4150085502159329 0.6813200889471304 1.0481321929018776 1.63955875788707 0.8202494 0.9199338 1.032494 0.9003552
chr1_140000000_150000000 chr1 144961953 chr1 146354609 1517 1962 3.6716631777873 2.11357346882856 1.812663773586434 0.9005212460400248 1.2318440000000002 0.8115817 1.062591 0.6445201999999999
chr1_140000000_150000000 chr1 140763448 chr1 142190534 227 659 1.3041431548779496 1.406507440097768 0.5009536861295639 3.0716651470194813 0.820837 0.9371286 1.000677 1.081401
chr1_140000000_150000000 chr1 143592531 chr1 147421635 1103 2276 2.5865753020925433 1.3819481939322038 1.0924453895054955 1.0375617989937647 0.9029075999999999 1.038225 0.9937063 1.0471780000000002
chr1_140000000_150000000 chr1 145250510 chr1 149576864 1611 2945 0.8182191157406982 0.796345423605383 1.666047353370258 2.1282722705911814 0.8923416 0.9964606 1.0717809999999999 1.0625879999999999
chr1_140000000_150000000 chr1 146934479 chr1 148359939 2129 2576 1.0980268900311336 1.1346231897970147 0.9154533573081597 1.511101936047537 7.689182e-01 1.051772e+00 8.951068e-01 1.102220e+00
chr1_140000000_150000000 chr1 147957592 chr1 148823582 2436 2722 0.7498920629119028 0.6440024169506774 0.99842459434732 1.5455348241355877 0.7810324000000001 0.8592556999999998 1.02486 0.589282
```

### Step 2: Filter loops based on distance:

```bash
cd significant.loopscore
cp ~/HIFI.bin/scripts/loop.compare/hifi.out/significant.loopscore/significant.filter.py .
cp ~/HIFI.bin/scripts/loop.compare/hifi.out/significant.loopscore/significant.filter.long.py .
```

```
ls -ltr
total 19002144
-rw-rw-r-- 1 qz64 qz64  300399966 Apr 18 07:15 18
-rw-rw-r-- 1 qz64 qz64  828453924 Apr 18 07:27 19
-rw-rw-r-- 1 qz64 qz64 1000749941 Apr 18 07:28 1
-rw-rw-r-- 1 qz64 qz64  955637858 Apr 18 07:29 15
-rw-rw-r-- 1 qz64 qz64  923395830 Apr 18 07:29 2
-rw-rw-r-- 1 qz64 qz64  956463877 Apr 18 07:30 6
-rw-rw-r-- 1 qz64 qz64  980752560 Apr 18 07:30 5
-rw-rw-r-- 1 qz64 qz64 1098369200 Apr 18 07:30 0
-rw-rw-r-- 1 qz64 qz64 1035397941 Apr 18 07:31 7
-rw-rw-r-- 1 qz64 qz64  986573513 Apr 18 07:31 10
-rw-rw-r-- 1 qz64 qz64 1022476126 Apr 18 07:31 17
-rw-rw-r-- 1 qz64 qz64  962272785 Apr 18 07:31 8
-rw-rw-r-- 1 qz64 qz64 1072899182 Apr 18 07:32 4
-rw-rw-r-- 1 qz64 qz64 1029640551 Apr 18 07:32 11
-rw-rw-r-- 1 qz64 qz64  990287603 Apr 18 07:32 9
-rw-rw-r-- 1 qz64 qz64 1062774261 Apr 18 07:32 12
-rw-rw-r-- 1 qz64 qz64 1065754726 Apr 18 07:32 16
-rw-rw-r-- 1 qz64 qz64 1107583373 Apr 18 07:33 3
-rw-rw-r-- 1 qz64 qz64 1020406555 Apr 18 08:03 14
-rw-rw-r-- 1 qz64 qz64 1057115818 Apr 18 08:03 13
```

```bash
mkdir short long
for i in `seq 0 19`; do python3 significance.filter.py $i > short/$i; done
for i in `seq 0 19`; do python3 significance.filter.long.py $i > long/$i; done
```

### Step 3: Short loops, get summarized z-scores (important)

Short loops are by definition less than 2,000,000bp looping distance. 
```bash
cd short
ls -ltr
total 54385440
-rw-rw-r-- 1 qz64 qz64  424929692 Apr 18 07:51 0
-rw-rw-r-- 1 qz64 qz64  385096767 Apr 18 07:51 1
-rw-rw-r-- 1 qz64 qz64  367959215 Apr 18 07:52 2
-rw-rw-r-- 1 qz64 qz64  448757414 Apr 18 07:52 3
-rw-rw-r-- 1 qz64 qz64  417382702 Apr 18 07:52 4
-rw-rw-r-- 1 qz64 qz64  392096329 Apr 18 07:53 5
-rw-rw-r-- 1 qz64 qz64  374966677 Apr 18 07:53 6
-rw-rw-r-- 1 qz64 qz64  405194723 Apr 18 07:53 7
-rw-rw-r-- 1 qz64 qz64  368429051 Apr 18 07:53 8
-rw-rw-r-- 1 qz64 qz64  387298292 Apr 18 07:54 9
-rw-rw-r-- 1 qz64 qz64  387079892 Apr 18 07:54 10
-rw-rw-r-- 1 qz64 qz64  389356801 Apr 18 07:54 11
-rw-rw-r-- 1 qz64 qz64  419944210 Apr 18 07:54 12
-rw-rw-r-- 1 qz64 qz64  373878639 Apr 18 07:55 15
-rw-rw-r-- 1 qz64 qz64  413451646 Apr 18 07:55 16
-rw-rw-r-- 1 qz64 qz64  396297026 Apr 18 07:56 17
-rw-rw-r-- 1 qz64 qz64  123398234 Apr 18 07:56 18
-rw-rw-r-- 1 qz64 qz64  319773030 Apr 18 07:56 19
-rw-rw-r-- 1 qz64 qz64  407892308 Apr 18 08:05 13
-rw-rw-r-- 1 qz64 qz64  394951647 Apr 18 08:05 14
```
First, merge all the 20 parts into a file called `all`.
```bash
#merge
for i in `seq 0 19`; do cat $i; done >> all
```

```bash
cd .. #should be in significant.loopscore
cp ~/HIFI.bin/scripts/loop.compare/hifi.out/significant.loopscore/do.significance.filter.sh .
cp ~/HIFI.bin/scripts/loop.compare/hifi.out/significant.loopscore/significance.filter.distance.3.py .
```

**significance.filter.distance.3.py** takes the short loops, and calculate an aggregate z-scores based on the **Stouffer's z-score formula**. The result is also known as a meta-zscore. The result is stored in `short/significant`. By default, the z-scores of **looping score** are being aggregated.

- Note, there is a version that aggregate OE scores instead of looping scores. If needed, then use the do.significance.filter.oe.sh and significance.filter.distance.oe.py files.

Run do.significance.filter.sh:
```
sbatch ./do.significance.filter.sh
```

The result is in short/significant:
```
[qz64@login03 short]$ head -n 10 significant
chr1 7531551 7531552 chr1 8502864 8502865 1.121913 0.8511524 0.8765455 0.7301494 1.1748586256344835 0.6374569223889195 1.2815006136571623
chr1 3036746 3036747 chr1 4537892 4537893 1.105651 0.9578460999999999 1.0316969999999999 0.8252562 0.6906372230425841 0.9717461246373873 1.1754825380761018
chr1 7664366 7664367 chr1 8553523 8553524 0.8334961 1.194408 0.9932287 0.9989664 -1.4436113798772188 -0.047680205054485655 -1.0545023924316423
chr1 5137220 5137221 chr1 6403084 6403085 1.271896 0.899856 0.7147564999999999 0.6137698 1.6190004888918703 0.43148129807578856 1.4499095762643412
chr1 6855852 6855853 chr1 7255094 7255095 1.070231 0.8776946 0.8632591 0.8637673 0.6576357331725045 -0.016436870387185464 0.45339606396460164
chr1 5856697 5856698 chr1 6065856 6065857 0.9040171999999999 1.3220379999999998 0.8680209999999999 0.8583165999999999 -1.3324043565585015 0.022876193671700507 -0.9259762441320186
chr1 5332057 5332058 chr1 6544105 6544106 0.8804142 0.7855588000000001 0.9465368000000001 1.0513700000000001 0.40345927606622717 -0.5021113589195918 -0.06975755676379125
chr1 6288408 6288409 chr1 6611762 6611763 1.023919 1.174215 0.9149252 0.8640407 -0.5039784301332957 0.17148987851584468 -0.235104909515593
chr1 3085704 3085705 chr1 4128418 4128419 0.8990808000000001 1.057828 0.9672014999999999 1.007268 -0.7086674870358219 -0.20833162460904808 -0.6484162901861276
chr1 8637940 8637941 chr1 9139386 9139387 0.8697033000000002 0.8603328000000001 1.07739 0.8982176 0.032909981542832756 0.6790310103185456 0.5034183031498572
```
There are three extra columns at the end:
- Z-score of looping score (first replicate, WT - KO)
- Z-score of looping score (second replicate, WT - KO)
- Meta-zscore


### Step 4: summarize differential loops by promoters, and by genes (promoter hubbiness score) (short loop version)

```
cd short
cp ~/HIFI.bin/scripts/loop.compare/hifi.out/significant.loopscore/short/get.tss.loops.py .
cp ~/HIFI.bin/scripts/loop.compare/hifi.out/significant.loopscore/short/anchors_mapped.bedmap .
```
Open up get.tss.loops.py:
```
vim get.tss.loops.py
```

Modify the part about aggregating genes or promoters:
If aggregate by anchors:
```python
    for i,j,k in by_anchor:
       print(i, j, k, by_anchor[(i, j, k)], freq_anchor[(i, j, k)], mx[(i, j, k)])
```
Or by genes:
```python
    for g in by_gene:
        print(g, by_gene[g], freq_gene[g])
```

By default, get.tss.loops.py will aggregate only meta-zscores > 1.5 or meta-zscores < -1.5. Everything else is ignored.

Run:
```
python3 get.tss.loops.py pos > pos.genes.txt
python3 get.tss.loops.py neg > neg.genes.txt
```

### Step 5a, b: Repeat Step 3, 4 for long loops


